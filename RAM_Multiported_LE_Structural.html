<html>
<head>
<link rel="shortcut icon" href="./favicon.ico">
<link rel="stylesheet" type="text/css" href="./style.css">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Implements a memory with multiple read and write ports which can all be used concurrently, implemented using logic elements, structurally described using decoders and multiplexers.">
<title>RAM Multiported LE Structural</title>
</head>
<body>

<p class="inline bordered"><b><a href="./RAM_Multiported_LE_Structural.v">Source</a></b></p>
<p class="inline bordered"><b><a href="./legal.html">License</a></b></p>
<p class="inline bordered"><b><a href="./index.html">Index</a></b></p>

<h1>Multi-Ported RAM using Logic Elements (Structural Implementation)</h1>
<p>Implements a memory with multiple read and write ports which can all be
 used concurrently, implemented using logic elements, structurally described
 using decoders and multiplexers.</p>
<p>This implementation describes the logic in a structural manner, built from
 known sub-modules which can all be directly ported to any other HDL, rather
 than depend on Verilog-specific features as in the <a href="./RAM_Multiported_LE_Behavioural.html">behavioural
 implementation</a>, at the cost of
 larger logic (but the same number of registers). The structural
 implementation also makes the operation under write-conflicts and
 out-of-bounds accesses well-defined, and easy to change as necessary for
 your application. </p>
<h2>Synthesis and Operation</h2>
<p>This kind of multi-ported memory is not expected to map to underlying RAM
 blocks, but it can support arbitrary numbers of read and write ports by
 using random logic and registers, <em>and can be bulk-cleared in a single
 cycle</em>. It will not scale well to large depths or widths, and become very
 large and slow. But it is suitable for small, highly-concurrent memories
 such as semaphores, small CPU register files, or storage for parallel
 functional units, and is the building block of more efficient, larger
 multi-ported memories.</p>
<p>The <code>RAMSTYLE</code> parameter is still provided for cases where the CAD tool
 might be able to map to RAM blocks, such as when <code>WRITE_PORT_COUNT</code> is 1.
 However, write-forwarding is not supported, unlike the <a href="./RAM_Simple_Dual_Port.html">Simple Dual Port
 RAM</a>, for example. </p>
<p>Expect warnings from the linter and your CAD tools if <code>DEPTH</code> is less than
 <code>ADDR_WIDTH**2</code>. It is allowable: <em>out-of-bounds reads and writes
 will respectively return zero and have no effect on the stored data.</em></p>
<p>Concurrent reads and writes to the same address always returns the
 currently stored data, not the data being written, which becomes readable
 in the next cycle.  The result of concurrent writes to the same address is
 defined by the <code>ON_WRITE_CONFLICT</code> parameter, which specifies the Boolean
 combination of the conflicting data writes to the same address.</p>
<h2>Parameters, Ports, and Constants</h2>
<p>Since we cannot have variable numbers of ports on a Verilog module, the
 read and write data, address, and enable ports are vectors which
 concatenate all the read/write ports in numerical order. Each individual
 read/write port behaves like every other read/write port. There is no
 distinction.</p>

<pre>
`default_nettype none

module <a href="./RAM_Multiported_LE_Structural.html">RAM_Multiported_LE_Structural</a>
#(
    parameter                       WORD_WIDTH          = 0,
    parameter                       READ_PORT_COUNT     = 0,
    parameter                       WRITE_PORT_COUNT    = 0,
    parameter                       ADDR_WIDTH          = 0,
    parameter                       DEPTH               = 0,
    parameter                       USE_INIT_FILE       = 0,
    parameter                       INIT_FILE           = "",
    parameter   [WORD_WIDTH-1:0]    INIT_VALUE          = 0,
    parameter                       RAMSTYLE            = "",
    parameter                       ON_WRITE_CONFLICT   = "", // e.g.: AND, OR, XOR, XNOR, etc...

    // Do not set at instantiation, except in IPI
    parameter TOTAL_READ_DATA  = WORD_WIDTH * READ_PORT_COUNT,
    parameter TOTAL_WRITE_DATA = WORD_WIDTH * WRITE_PORT_COUNT,
    parameter TOTAL_READ_ADDR  = ADDR_WIDTH * READ_PORT_COUNT,
    parameter TOTAL_WRITE_ADDR = ADDR_WIDTH * WRITE_PORT_COUNT
)
(
    input   wire                            clock,
    input   wire                            clear,

    input   wire    [TOTAL_WRITE_DATA-1:0]  write_data,
    input   wire    [TOTAL_WRITE_ADDR-1:0]  write_address,
    input   wire    [WRITE_PORT_COUNT-1:0]  write_enable,

    output  wire    [TOTAL_READ_DATA-1:0]   read_data,
    input   wire    [TOTAL_READ_ADDR-1:0]   read_address,
    input   wire    [READ_PORT_COUNT-1:0]   read_enable
);

    localparam WORD_ZERO            = {WORD_WIDTH{1'b0}};
    localparam WRITE_ADDR_HIT_ZERO  = {WRITE_PORT_COUNT{1'b0}};
    localparam TOTAL_STORED_DATA    = WORD_WIDTH * DEPTH;
    localparam TOTAL_STORED_ZERO    = {TOTAL_STORED_DATA{1'b0}};
</pre>

<h2>RAM Array</h2>
<p>CAD tools expect a memory description like this, an arrays of registers, to
 infer RAM and to enable initializing from a file. The CAD tool will <em>try</em>
 to map the memory to the specified <code>RAMSTYLE</code>.</p>

<pre>
    (* ramstyle  = RAMSTYLE *) // Quartus
    (* ram_style = RAMSTYLE *) // Vivado

    reg [WORD_WIDTH-1:0] ram [DEPTH-1:0];
</pre>

<h2>Write Ports and Storage</h2>
<p>For each <code>ram</code> array location, decode the <code>write_address</code> from each write
 port, masked by each write port's <code>write_enable</code> bit. If an address
 matches, then store the write data from that write port into that <code>ram</code>
 array location.  If no write address matches the <code>ram</code> location, then no
 write is enabled to that <code>ram</code> location.  Thus, if the write address
 exceeds the depth of the <code>ram</code>, nothing happens.  Conflicting write data
 are merged via the Boolean operation specified by <code>ON_WRITE_CONFLICT</code>.</p>

<pre>
    generate
    genvar i, j;

        reg [TOTAL_STORED_DATA-1:0] stored_data = TOTAL_STORED_ZERO;

        for (i=0; i < DEPTH; i=i+1) begin: per_ram_unit
</pre>

<h3>Option: Out-Of-Bounds Write Handling</h3>
<p>By calculating <a href="./Arithmetic_Predicates_Binary.html">arithmetic predicates</a>
 here to compare the write address with <code>DEPTH</code>, you could detect
 out-of-bounds writes.</p>

<pre>
            wire [WRITE_PORT_COUNT-1:0] write_addr_hit;

            for (j=0; j < WRITE_PORT_COUNT; j=j+1) begin: per_write_port
                <a href="./Address_Decoder_Behavioural.html">Address_Decoder_Behavioural</a>
                #(
                    .ADDR_WIDTH (ADDR_WIDTH)
                )
                write_address_decoder
                (
                    .base_addr  (i [ADDR_WIDTH-1:0]), // Must trim to width to avoid lint warnings.
                    .bound_addr (i [ADDR_WIDTH-1:0]),
                    .addr       (write_address [ADDR_WIDTH*j +: ADDR_WIDTH]),
                    .hit        (write_addr_hit [j])
                );
            end
</pre>

<h3>Option: Write Conflict Handling</h3>
<p>Here we compute the final write enable to this particular <code>ram</code> location.
 This is where you would handle conflicting writes, by using a <a href="./Arbiter_Priority.html">Priority
 Arbiter</a> for example. Or maybe return an error
 signal or delay a ready/valid handshake from completing. Or store the
 conflicting writes into a queue, or report the conflict as metadata when
 reading out, etc...</p>

<pre>
            reg write_enable_ram = 1'b0;

            always @(*) begin
                write_enable_ram = ((write_addr_hit & write_enable) != WRITE_ADDR_HIT_ZERO);
            end

            wire [WORD_WIDTH-1:0] write_data_selected;

            <a href="./Multiplexer_One_Hot.html">Multiplexer_One_Hot</a>
            #(
                .WORD_WIDTH     (WORD_WIDTH),
                .WORD_COUNT     (WRITE_PORT_COUNT),
                .OPERATION      (ON_WRITE_CONFLICT),
                .IMPLEMENTATION ("AND")
            )
            write_data_mux
            (
                .selectors      (write_addr_hit),
                .words_in       (write_data),
                .word_out       (write_data_selected)
            );
</pre>

<h3>Storage</h3>
<p>Rather than use a <a href="./Register.html">Register</a> module for each <code>ram</code>
 location, we implement the writing and reset logic directly here, since we
 <em>must</em> use a reg array to enable initializing <code>ram</code> from a file later on.
 This code uses the <a href="./verilog.html#resets">"Last Assignment Wins"</a> reset
 idiom.</p>

<pre>
            always @(posedge clock) begin
                if (write_enable_ram == 1'b1) begin
                    ram [i] <= write_data_selected;
                end
                if (clear == 1'b1) begin
                    ram [i] <= INIT_VALUE;
                end
            end
</pre>

<h3>Flattening</h3>
<p>Here, we flatten the outputs of the <code>ram</code> reg array into a single vector so
 each read port can later select the desired data word. This isn't strictly
 necessary, but a single multiplexer is more modular than nested loops
 iterating over each memory location for each read port. </p>

<pre>
            always @(*) begin
                stored_data [WORD_WIDTH*i +: WORD_WIDTH] = ram [i];
            end

        end

    endgenerate
</pre>

<h2>Read Ports</h2>
<p>For each read port, we use the <code>read_address</code> to select the desired data
 word, and register it as output if <code>read_enable</code> is set that cycle. If the
 <code>read_address</code> is greater than the <code>ram</code> <code>DEPTH</code>, then <code>read_data</code> returns
 zero (and such an out-of-bounds access could also be detected here).</p>

<pre>
    generate
    genvar k;

        wire [TOTAL_READ_DATA-1:0] read_data_internal;

        for (k=0; k < READ_PORT_COUNT; k=k+1) begin: per_read_port
            <a href="./Multiplexer_Binary_Structural.html">Multiplexer_Binary_Structural</a>
            #(
                .WORD_WIDTH     (WORD_WIDTH),
                .ADDR_WIDTH     (ADDR_WIDTH),
                .INPUT_COUNT    (DEPTH),
                .OPERATION      ("OR"),
                .IMPLEMENTATION ("AND")
            )
            read_data_selector
            (
                .selector       (read_address [ADDR_WIDTH*k +: ADDR_WIDTH]),
                .words_in       (stored_data),
                .word_out       (read_data_internal [WORD_WIDTH*k +: WORD_WIDTH])
            );
</pre>

<p>The output is registered to match the behaviour of synchronous RAMs, but
 also to pipeline the above <em>large</em> multiplexers.</p>

<pre>
            <a href="./Register.html">Register</a>
            #(
                .WORD_WIDTH     (WORD_WIDTH),
                .RESET_VALUE    (WORD_ZERO)
            )
            read_port_output
            (
                .clock          (clock),
                .clock_enable   (read_enable [k]),
                .clear          (clear),
                .data_in        (read_data_internal [WORD_WIDTH*k +: WORD_WIDTH]),
                .data_out       (read_data          [WORD_WIDTH*k +: WORD_WIDTH])
            );
        end

    endgenerate
</pre>

<h2>Memory Initialization</h2>
<p>If you are not using an init file, the following code will set all memory
 locations to INIT_VALUE. The CAD tool should generate a memory
 initialization file from that.  This is useful to cleanly zero-out memory
 without having to deal with an init file.  Your CAD tool may complain about
 too many for-loop iterations if your memory is very deep. Adjust the tool
 settings to allow more loop iterations.</p>
<p>At a minimum, the initialization file format is one value per line, one for
 each memory word from 0 to DEPTH-1, in bare hexadecimal (e.g.: 0012 to init
 a 16-bit memory word with 16'h12). Note that if your WORD_WIDTH isn't
 a multiple of 4, the CAD tool may complain about the width mismatch.
 You can base yourself on this Python <a href="./RAM_generate_empty_init_file.py">memory initialization file
 generator</a>.</p>

<pre>
    generate
        if (USE_INIT_FILE == 0) begin
            integer l;
            initial begin
                for (l=0; l < DEPTH; l=l+1) begin: per_ram_word
                    ram[l] = INIT_VALUE;
                end
            end
        end
        else begin
            initial begin
                $readmemh(INIT_FILE, ram);
            end
        end
    endgenerate

endmodule
</pre>

<hr>
<p><a href="./index.html">Back to FPGA Design Elements</a>
<center><a href="http://fpgacpu.ca/">fpgacpu.ca</a></center>
</body>
</html>

