<html>
<head>
<link rel="shortcut icon" href="./favicon.ico">
<link rel="stylesheet" type="text/css" href="./style.css">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="A signed binary integer adder/subtractor, with `carry_in`, `carry_out`, `overflow`, and all the intermediate `carries` into each bit position (see [Carry-In Calculator](./CarryIn_Binary.html) for their uses).">
<title>Adder Subtractor Binary</title>
</head>
<body>

<p class="inline bordered"><b><a href="./Adder_Subtractor_Binary.v">Source</a></b></p>
<p class="inline bordered"><b><a href="./legal.html">License</a></b></p>
<p class="inline bordered"><b><a href="./index.html">Index</a></b></p>

<h1>Binary Integer Adder/Subtractor</h1>
<p>A signed binary integer adder/subtractor, with <code>carry_in</code>, <code>carry_out</code>,
 <code>overflow</code>, and all the intermediate <code>carries</code> into each bit position (see
 <a href="./CarryIn_Binary.html">Carry-In Calculator</a> for their uses).</p>
<p>Addition/subtraction is selected with <code>add_sub</code>: 0 for an add
 (<code>A+B+carry_in</code>), and 1 for a subtract (<code>A-B-carry_in</code>). This assignment
 conveniently matches the convention of sign bits. Note that the <code>overflow</code>
 bit is only meaningful for signed numbers. For unsigned numbers, use
 <code>carry_out</code> instead.</p>
<p>On FPGAs, you are much better off letting the CAD tool infer the
 add/subtract circuitry from the <code>+</code> or <code>-</code> operator itself, rather than
 structurally describing it in logic, as the latter may not get mapped to
 the fast, dedicated ripple-carry hardware. Wrapping all this into a module
 hides the width adjustments necessary to get a warning-free synthesis of
 carry logic, and enables correct carry and overflow calculations.</p>
<p>Because we handle the carry bits ourselves and do everything through an
 unsigned addition, we don't depend on the tricky Verilog behaviour where
 all terms of an expression must be declared signed else the expression is
 silently evaluated as unsigned!</p>

<pre>
`default_nettype none

module <a href="./Adder_Subtractor_Binary.html">Adder_Subtractor_Binary</a>
#(
    parameter       WORD_WIDTH = 0
)
(
    input   wire                        add_sub,    // 0/1 -> A+B/A-B
    input   wire                        carry_in,
    input   wire    [WORD_WIDTH-1:0]    A,
    input   wire    [WORD_WIDTH-1:0]    B,
    output  reg     [WORD_WIDTH-1:0]    sum,
    output  reg                         carry_out,
    output  wire    [WORD_WIDTH-1:0]    carries,
    output  reg                         overflow
);

    localparam ZERO = {WORD_WIDTH{1'b0}};

    initial begin
        sum         = ZERO;
        carry_out   = 1'b0;
        overflow    = 1'b0;
    end
</pre>

<p>Extend the <code>carry_in</code> to the <em>unsigned</em> extended word width, so we don't
 have width mismatches nor rely on sign extension, which is full of
 pitfalls, and would trigger useless warnings in the CAD tools.</p>

<pre>
    wire [WORD_WIDTH-1:0] carry_in_extended;

    <a href="./Width_Adjuster.html">Width_Adjuster</a>
    #(
        .WORD_WIDTH_IN  (1),
        .SIGNED         (0),
        .WORD_WIDTH_OUT (WORD_WIDTH)
    )
    extend_carry_in
    (
        .original_input     (carry_in),
        .adjusted_output    (carry_in_extended)
    );
</pre>

<p>Generate the 2's-complement negations of <code>B</code> and <code>carry_in_extended</code>. We do
 this separately to have the negated terms available later for the
 calculations of the <code>carries</code> and of the <code>overflow</code>.</p>

<pre>
    reg [WORD_WIDTH-1:0] B_negated                 = ZERO;
    reg [WORD_WIDTH-1:0] carry_in_extended_negated = ZERO;

    always @(*) begin
        B_negated                 = -B;
        carry_in_extended_negated = -carry_in_extended;
    end
</pre>

<p>Then, select the addition terms, depending on the <code>add_sub</code> operation.</p>

<pre>
    reg [WORD_WIDTH-1:0] B_selected         = ZERO;
    reg [WORD_WIDTH-1:0] carry_in_selected  = ZERO;

    always @(*) begin
        B_selected          = (add_sub == 1'b0) ? B                 : B_negated;
        carry_in_selected   = (add_sub == 1'b0) ? carry_in_extended : carry_in_extended_negated;
    end
</pre>

<p>And add as usual. Since the left-hand side is one bit wider to hold
 <code>carry_out</code>, all other terms are implicitly extended to that width (see
 Verilog LRM, IEEE 1364-2001, Section 4.4, "Expression bit lengths").
 However, since I avoid implicit width extension as a way to reduce warnings
 and prevent bugs, let's prepend a zero to all the unsigned right-hand terms
 to make all widths match.</p>
<p>We could have done this more concisely by first widening all terms to
 <code>WORD_WIDTH+1</code>, then selecting addition/subtraction in one line, but we
 need the possibly negated terms later for the <code>carries</code> and <code>overflow</code>
 calculation.</p>

<pre>
    always @(*) begin
        {carry_out, sum} = {1'b0, A} + {1'b0, B_selected} + {1'b0, carry_in_selected};
    end
</pre>

<p>Finally, recover the carry <em>into</em> each bit from the selected addition
 terms.  The first bit of <code>carries</code> is the same as <code>carry_in</code>.  We must do
 this here rather than in the enclosing module, since if you are
 subtracting, the negated <code>B</code> term is not externally available.</p>

<pre>
    <a href="./CarryIn_Binary.html">CarryIn_Binary</a>
    #(
        .WORD_WIDTH (WORD_WIDTH)
    )
    per_bit
    (
        .A          (A),
        .B          (B_selected),
        .sum        (sum),
        .carryin    (carries)
    );
</pre>

<p>And compute the signed overflow, when the carry into and out from the MSB
 do not agree.</p>

<pre>
    always @(*) begin
        overflow = (carries [WORD_WIDTH-1] != carry_out);
    end

endmodule
</pre>

<hr>
<p><a href="./index.html">Back to FPGA Design Elements</a>
<center><a href="http://fpgacpu.ca/">fpgacpu.ca</a></center>
</body>
</html>

